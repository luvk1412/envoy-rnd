# envoy-rnd

Testing envoy on local

### Tools Installation

- Install [minikube](https://minikube.sigs.k8s.io/docs/start/?arch=%2Fmacos%2Farm64%2Fstable%2Fhomebrew)

```bash
brew install minikube
```

- Install helm

```bash
brew install helm
```

## envoy-setup

- Start minikube

```bash
minikube start
```

- Setup envoy gateway <br/>

```bash
helm install eg oci://docker.io/envoyproxy/gateway-helm --version v1.1.0 -n envoy-gateway-system --create-namespace
```

- Wait for envoy gateway to set up

```bash
kubectl wait --timeout=5m -n envoy-gateway-system deployment/envoy-gateway --for=condition=Available
```

- Setup example app and routes

```bash
kubectl apply -f envoy/config.yaml -n default
```

- Restart envoy-gateway. This is optional but in the case of applying envoy/config.yaml, there is a custom configMap which is
  created in the cluster to enabled EnvoyPatchPolicy. In order for that configMap to take effect we need to restart envoy-gateway.
  If EnvoyPatchPolicy is not something you required, this restart is not required.

```bash
kubectl rollout restart deployment envoy-gateway -n envoy-gateway-system
```

- Get name of envoy service

```bash
export ENVOY_SERVICE=$(kubectl get svc -n envoy-gateway-system --selector=gateway.envoyproxy.io/owning-gateway-namespace=default,gateway.envoyproxy.io/owning-gateway-name=eg -o jsonpath='{.items[0].metadata.name}')
```

- Port forward envoy to localhost

```bash
kubectl -n envoy-gateway-system port-forward service/${ENVOY_SERVICE} 8888:80
```

- Example curl you can hit

```bash
curl -X POST http://localhost:8888/service1/post \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_access_token_here" \
  -H "X-Session-Token: token1" \
  -H "Custom-Header: custom_value" \
  -d '{"key1": "value1", "key2": "value2"}'
 ```

- Port forwarding can also be set using lens. Go to Network > Services > <gateway service> and click port forward and forward to
  8888

## envoy-cleanup

- Delete config

```bash
kubectl delete -f envoy/config.yaml --ignore-not-found=true
```

- Delete envoy

```bash
helm uninstall eg -n envoy-gateway-system
```

- Delete minikube

```bash
minikube delete
```

## Docker setup

Server used for testing can be built using below commands. It's a simple python echo server

- Use docker inside minikube daemon, will be only valid for that terminal session

```bash
eval $(minikube docker-env)
```

- Build echo server image

```bash
docker build --platform=linux/amd64 -t python-echo echo_server/.
```

- Build auth server image

```bash
docker build --platform=linux/amd64 -t python-auth auth_server/.
```

## Envoy-Proxy Setup

- Create config map for envoy proxy. Below command will update the configmap if already exists

```bash
  kubectl create configmap envoy-config --from-file=envoy.yaml=envoy_proxy/envoy.yaml --dry-run=client -o yaml | kubectl apply -f -
```

- Setup python app with sidecar envoy proxy

```bash
kubectl apply -f envoy_proxy/config.yaml
```

- Port forward

```bash
kubectl port-forward service/python-envoy-service 8080:80
```

- Hit below curl for testing

```bash
curl -v -X POST http://localhost:8080/service1/post \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer your_access_token_here" \
  -H "X-Session-Token: my_token" \
  -H "Custom-Header: custom_value" \
  -d '{"key1": "value1", "key2": "value2"}'
```

## EnvoyPatchPolicy

To change envoy specific dynamic configuration, we need to patch xDs config using EnvoyPatchPolicy.
TO know what needs to be exactly modified we can check the xDS generated by egctl command and see the translated
config to know json path where something is tp be added.

In source file which is getting translated you would also notice that the Services are commented out. This is because egctl
command fails if you don't provide a static clusterIP

- egctl command to see xDS translation

```bash
egctl x translate --from gateway-api --to xds -f envoy/translation_testing/config_to_translate.yaml > envoy/translation_testing/config_translated.yaml

```

## [Security Policy](https://gateway.envoyproxy.io/docs/api/extension_types/#securitypolicy)

Envoy provides a custom CRD called `SecurityPolicy` using which we can centralise auth. If we apply this to a `HttpRoute`, all
requests for that route would go through auth server defined in `SecurityPolicy`.

### `path` field in SecurityPolicy

In our defined Security Policies, you would notice we have added path as `/fa/auth?path=`. This endpoint exists there
in achilles service. Question might come why is there a `?path=` at the end and would it work without that. The answer is No.
The envoy gateway's naming convention here is a bit misleading. the corresponding field for 'path' in Envoy Proxy api's is
called `path_prefix` definition of which can be found
in [extensions.filters.http.ext_authz.v3.HttpService](https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/http/ext_authz/v3/ext_authz.proto#extensions-filters-http-ext-authz-v3-httpservice).
So this field basically denotes the path prefix which will be added to the incoming req url, and then that final value will be
used to hit the mentioned target. This value does not denote an endpoint. For eg: if incoming req url is `/servic1/get` and
path value is `/fa/envoy/validate`, then final endpoint would become `/fa/envoy/validate/servic1/get` and filter will try to
hit this endpoint which will result in 404. Hence, we use `/fa/auth?path=`, which results
in `/fa/auth?path=/servic1/gets` making incoming req url as req parameter.